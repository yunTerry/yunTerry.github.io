<?xml version="1.0" encoding="utf-8"?><search><entry><title>Serverless 会是一场云计算的革命吗</title><url>/serverless/</url><content><![CDATA[<p><em>微服务方兴未艾，Serverless 横空出世。</em></p><p>关于 Serverless，网上众说纷纭，本人也是前几个月刚刚了解到 Serverless，但第一次看到 Serverless 就感觉，这就是我想要的，这应该就是云计算的未来。</p><p><img src="/pic/serverless/1.gif" alt=""><a id="more"></a></p><h2 id="什么是Serverless"><a href="#什么是Serverless" class="headerlink" title="什么是Serverless"></a>什么是 Serverless</h2><p>Serverless 通常被翻译成无服务器架构，它是一种事件驱动的函数级计算服务，同时也是一种极致的微服务设计，弹性伸缩能力无与伦比。</p><p>Serverless 平台是一种高度抽象的代码运行环境，它能直接冷启动一段逻辑代码，既简单易用又无比强大，用户无需管理服务器，仅仅写出业务逻辑代码就能即刻运行。</p><p>目前 Serverless 的主要形态是 FaaS（Function as a Service），国外有 AWS Lambda、Azure Functions、Google Cloud Functions 等，国内阿里云、腾讯云等都提供了 FaaS 函数计算服务。</p><p>由于还处于很早期的阶段，毫无疑问，Serverless 还有很多缺点，比如实时性不足、运行时长限制等，但相信随着技术的进步，这些问题都会逐步解决，本文只谈谈 Serverless 相对传统基础设施的优势，以及为什么 Serverless 很可能是云计算的未来趋势。</p><h2 id="一切皆因成本"><a href="#一切皆因成本" class="headerlink" title="一切皆因成本"></a>一切皆因成本</h2><p>大学时无意中在图书馆看到一本书《问道云计算》，书中一个观点令人印象深刻，作者认为云计算就像是国家电网，通用的计算服务将会成为像电力这样的社会基础设施。</p><p><img src="/pic/serverless/2.jpg" alt=""></p><p>现在用电很方便，牵根电线安个电表就行了，你不开电器电表就不会转，每月电表转多少度国家电网收你多少钱，这些都太平常不过了，然而这要放到云计算，简直不可思议。</p><p>试想如果你家的电表换成以时间计费，你愿意么？也就是给你牵根电线，然后不管你用没用、用多少，每时每刻都要给你计费，而且始终按最高 “功率” 计费，你可能会惊呼：这 TM 就是赤裸裸的抢劫啊！</p><p><img src="/pic/serverless/3.jpg" alt=""></p><p>然而现在的云计算公司就是这么干的，你按 CPU 核数、内存、带宽买云服务，不管你用没用、用多少，每时每刻都要给你计费，而且电力功率还有限制（按你购买的 CPU 核数、带宽等），超出功率就给你断闸限电……</p><p>但这也并不代表云计算公司多么暴利，因为它们提供的基本都是虚拟机或容器实例，但这些实例的弹性伸缩能力太差，大部分时间都在空转浪费，偶尔高峰期又力不从心，虽然它们也不想这样，但这种浪费终究还是用户买单。</p><p>为此 AWS 很早就提供了 EC2 竞价实例试图提高实例的利用率，现在很多云计算公司都推出了按秒计费的云服务器，但这依然还是延续着那种粗暴的按时间计费的方式，不过是营销的套路而已，用户的使用成本依旧高昂。</p><p><img src="/pic/serverless/4.jpg" alt=""></p><p>在所有的经济活动中，成本一定是首要考虑的因素之一，Serverless 对传统云服务的颠覆就在于它极大的成本优势，它能精确地按计算量来计费，就像电表按用电量计费，与时间无关一样，避免了虚拟机、容器大量的计算资源闲置浪费，对普通用户来说，成本上可以秒杀虚拟机和容器，能够大幅降低云计算服务的价格。</p><h2 id="IT的基础设施"><a href="#IT的基础设施" class="headerlink" title="IT的基础设施"></a>IT 的基础设施</h2><p>要成为基础设施，首先是要让人放心，但目前云计算依然是一件让人操心的事情，开发部署应用时你需要考虑可扩展性、高可用性，每个服务一般都要部署多个实例，还要做服务注册发现、负载均衡、容错断路等，容器还要用 Kubernetes 管理集群……</p><p>但对开发人员而言，他们只想专注于业务逻辑，并不想为服务器管理和运维有关的基础设施问题操心。</p><p>Serverless 几乎把这些 IT 的基础设施问题一次性解决了，Serverless 天然具备高可用、完全的弹性伸缩等特点。</p><p>国外的工程师给 Serverless 打出的一句口号就是：</p><blockquote><p><strong>“ Focus on your application, not your infrastructure ”</strong></p></blockquote><h2 id="云计算的门槛"><a href="#云计算的门槛" class="headerlink" title="云计算的门槛"></a>云计算的门槛</h2><p>现在的云服务就像是早期的发电站一样，提供的是不同电压不同功率的电力，你得自己买变压器、自己去捣腾电压频率然后才能用，Serverless 则是直接让国家电网给你 220V 50Hz 的电力，你直接插上插头就能用了。</p><p>Serverless 就像插座一样即插即用，极大地降低了云计算的接入使用门槛，通过 FaaS 加 API 网关基本上可以重构大部分的企业级应用。</p><p>Serverless 对传统的软件架构是颠覆性的，未来在 Serverless 平台上创建高可用、高可扩展性的微服务将是异常简单的事情，只写点业务代码就行了，你根本不用去考虑架构、扩展、并发之类的问题，因为云计算公司会用它们最优的架构和扩展来构筑 Serverless 的底层基础设施，使其上的应用天然具备分布式系统和微服务架构的所有优势。</p><p>虽然未来云计算公司可能仍然使用 Kubernetes 等容器技术构建 Serverless 底层基础，但云计算用户可能不会再接触虚拟机和容器了，直接面向 Serverless 开发就行了，普通人也完全没必要花大价钱买云主机或容器服务，既麻烦又浪费。</p><h2 id="熵的转移"><a href="#熵的转移" class="headerlink" title="熵的转移"></a>熵的转移</h2><p>从单机到分布式集群，从虚拟机到容器，从单体应用到微服务架构，无论 IT 系统如何演变，系统的复杂性都不会降低，而且还会呈指数级增加，这就像物理世界的熵增加原理一样，系统只会演变得越来越复杂和难以管理。</p><p>实际中应用开发越来越简单是因为我们不断把复杂性从上层转移到下层，最终通过自动化程序把复杂性从人转移给了机器，让机器承担底层越来越复杂的重担，通过这样的复杂性转移就能不断降低 IT 系统的成本。</p><p>Serverless 对传统的 IT 系统架构是颠覆性的，它更彻底地把复杂性转移给了基础设施，把 IT 系统的熵不断转移给机器，剩下的只是业务的复杂性。</p><h2 id="重新定义云应用"><a href="#重新定义云应用" class="headerlink" title="重新定义云应用"></a>重新定义云应用</h2><p>传统的应用都是常驻内存型，每个应用启动时都需要开辟自己的进程并常驻在 CPU、内存中，这种应用不仅长时间占用硬件资源，而且启动速度很慢，例如在容器环境中，使用 Java 开发的微服务启动速度明显偏慢，而运行在 Serverless 平台上的短时间、快速启动的函数单元则具有明显优势。</p><p>Serverless 一个了不起的地方就是它的应用不是常驻内存的，只有你去唤醒它，触发它的事件时才会占用计算资源，其他时间都是退出硬件静静地躺在硬盘上的文件而已。</p><p>很多人以为提供虚拟机、容器服务就是云计算了，以为虚拟机容器就能把计算资源抽象出来了，那其实和以前的服务器租赁没啥区别，正如《问道云计算》书中所说，它们并没有构建出通用的计算资源池，真正的云计算应该像 Serverless 这样，对硬件基础设施进一步抽象，构建出通用的计算资源池。从这个角度来看，Serverless 在重新定义云计算的形态。</p><p><img src="/pic/serverless/5.jpg" alt=""></p><p>除了云基础设施，Serverless 同时也在重新定义云应用，传统的软件形态可能必须重构，运行在 Serverless 平台上的无状态函数式应用可能才是云应用的应有形态。</p><h2 id="展望Serverless未来"><a href="#展望Serverless未来" class="headerlink" title="展望Serverless未来"></a>展望 Serverless 未来</h2><p>现在云计算产业正如火如荼地发展，未来 Serverless 很可能是决定公有云竞争格局的关键因素，得 Serverless 者得天下。</p><p>未来的 Serverless 平台上，通过函数式应用调起硬件资源，不管底层是 CPU、GPU、FPGA 还是 ASIC，都可以通过 FaaS 提供计算服务；上层都是统一的函数式应用，不管你是普通的 Web 服务、大数据处理还是神经网络训练，都可以通过 FaaS 获取计算服务。</p><p>当然目前来看，Serverless 还远未成熟，但从未来来看，Serverless 必将是云计算的一道曙光，甚至是云计算的一场革命。</p>]]></content><categories><category>云计算</category></categories><tags><tag>微服务</tag><tag>Serverless</tag></tags></entry><entry><title>Kubernetes 使用 NFS 部署应用</title><url>/k8s-nfs/</url><content><![CDATA[<p>在分布式系统中，经常需要跨机器存取数据，用 NFS（Network File System）做数据持久化，可以很方便地在节点间共享存储资源，本文介绍如何在 Kubernetes 中使用 NFS 作存储后端。</p><p><img src="/pic/kube/k8s.jpg" alt=""><a id="more"></a></p><h2 id="安装NFS"><a href="#安装NFS" class="headerlink" title="安装NFS"></a>安装 NFS</h2><p>NFS 安装很简单，以我使用的 Alpine Linux 为例，安装 nfs 工具包：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">apk add nfs-utils</span><br></pre></td></tr></tbody></table></figure><p></p><p>创建一个 nfs 服务端目录，然后配置服务<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">mkdir /nfs</span><br><span class="line"><span class="comment"># 增加读写权限</span></span><br><span class="line">chmod a+rw -R /nfs</span><br><span class="line"><span class="comment"># 配置 NFS 服务</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/nfs *(rw,sync,no_root_squash)'</span> &gt;&gt; /etc/exports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动NFS</span></span><br><span class="line">service nfs start </span><br><span class="line"><span class="comment"># 开机自动启动</span></span><br><span class="line">rc-update add nfs boot</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="测试NFS"><a href="#测试NFS" class="headerlink" title="测试NFS"></a>测试 NFS</h2><p>创建一个测试目录，并尝试挂载<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 测试目录</span></span><br><span class="line">mkdir <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 挂载NFS目录</span></span><br><span class="line">mount 192.168.199.24:/nfs <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>查看挂载信息<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">devtmpfs                 10.0M         0     10.0M   0% /dev</span><br><span class="line">shm                       1.9G         0      1.9G   0% /dev/shm</span><br><span class="line">/dev/sda3                 5.8G    120.5M      5.4G   2% /</span><br><span class="line">tmpfs                   394.8M    132.0K    394.6M   0% /run</span><br><span class="line">/dev/sda1                92.8M     13.3M     72.5M  15% /boot</span><br><span class="line">192.168.199.24:/nfs       5.8G    120.5M      5.4G   2% /root/<span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到已经把 NFS 服务挂载到 test 目录下</p><h2 id="在Kubernetes中使用NFS服务"><a href="#在Kubernetes中使用NFS服务" class="headerlink" title="在Kubernetes中使用NFS服务"></a>在 Kubernetes 中使用 NFS 服务</h2><p>在 Kubernetes 中，存储资源的生产者和消费者被抽象为 PersistentVolume 和 PersistentVolumeClaim 两个对象，通过这两个 API 实现应用数据持久化。</p><p>创建一个 PersistentVolume，挂载 NFS<br></p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">postgres-pv</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">NFS</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">standard</span></span><br><span class="line"><span class="attr">  persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteMany</span></span><br><span class="line"><span class="attr">  nfs:</span></span><br><span class="line">    <span class="comment"># nfs服务端地址</span></span><br><span class="line"><span class="attr">    server:</span> <span class="number">192.168</span><span class="number">.199</span><span class="number">.24</span></span><br><span class="line">    <span class="comment"># 服务端目录</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/nfs/postgre</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="部署PostgreSQL"><a href="#部署PostgreSQL" class="headerlink" title="部署PostgreSQL"></a>部署 PostgreSQL</h2><p>使用刚才创建的 NFS 服务，在 Kubernetes 集群中部署 PostgreSQL。</p><p>创建 statefulset 和 service，完整代码见：<a href="https://github.com/yunTerry/K8s-Postgre" target="_blank" rel="noopener">https://github.com/yunTerry/K8s-Postgre</a></p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建PersistentVolume</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">pg-volume.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署PostgreSQL</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">pg-statefulset.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建service</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="bullet">-f</span> <span class="string">pg-service.yml</span></span><br></pre></td></tr></tbody></table></figure><p>在 DashBoard 中查看应用部署情况</p><p><img src="/pic/kube/postgre.jpg" alt=""></p><p>可以看到已经启动了两个 PostgreSQL 实例，它们共用 NFS 服务。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>Service 是对一组 pod 实例的抽象，方便做服务发现和负载均衡。默认情况下，服务是以 ClusterIP 形式运行在集群内部的，如果想要从外部访问，可以通过 Ingress、LoadBalancer 或 NodePort 将服务暴露出来。</p><p>但通常并不需要把服务暴露出去，比如数据库这种让它待在 K8s 集群内就好了，借助 kube-dns 强大的服务发现能力，集群内应用可以通过服务名直接连接，这就类似于我们在 Spring Cloud 中用 Eureka 做服务注册发现，不过用 kube-dns 的方式更方便。</p><p>此外，在 Docker compose 中也提供了类似的服务发现能力，具体可以参考之前的代码：<br><a href="https://github.com/yunTerry/Spring-Cloud-Docker" target="_blank" rel="noopener">https://github.com/yunTerry/Spring-Cloud-Docker</a></p><p>Kubernetes 就像一个王国，通过强大的服务发现能力，各种应用可以在这个王国里自由交流，但又与世隔绝，不受外界干扰，必要时也可以开个小门（Ingress），而且这个王国还可以随意拓展疆土（kubeadm join）。</p><h2 id="本文源码"><a href="#本文源码" class="headerlink" title="本文源码"></a>本文源码</h2><p><a href="https://github.com/yunTerry/K8s-Postgre" target="_blank" rel="noopener">https://github.com/yunTerry/K8s-Postgre</a></p>]]></content><categories><category>容器</category></categories><tags><tag>服务发现</tag><tag>Kubernetes</tag><tag>Linux</tag></tags></entry><entry><title>基于 Keras 卷积神经网络的图片识别</title><url>/keras-cnn/</url><content><![CDATA[<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>我们知道图片是由大量像素点构成的，每个像素点又由 RGB 颜色值构成，用计算机识别图片，如果直接分析各个像素点和它们的颜色值，计算量就非常大，分析会很复杂和低效，卷积神经网络 (CNN，Convolutional Neural Network) 通过卷积运算快速从大量数据中提取出各种特征，然后用神经网络对浓缩后的特征数据进行快速分析，就能高效地处理图片。</p><p><img src="/pic/keras/kf.jpg" alt=""><a id="more"></a></p><p><a href="https://github.com/keras-team/keras" target="_blank" rel="noopener">Keras</a> 是 TensorFlow 中一个高层神经网络 API，用 Keras 可以很方便地构建和训练神经网络模型，官方也提供了在 ImageNet 数据集上训练的 ResNet-50 模型，ResNet 叫残差网络，ResNet-50 是一种深度卷积神经网络，该神经网络模型既轻量又有很高的识别准确率。</p><h2 id="图片识别API"><a href="#图片识别API" class="headerlink" title="图片识别API"></a>图片识别 API</h2><p>这里基于 Keras 的预训练模型 ResNet-50 做一个图片识别应用，为了易于使用，我们把图片识别部分封装成 RESTful API，客户端通过 Http 请求把图片传给后端，服务端完成识别后把结果返回给客户端，客户端再用某种可视化的方式展示出来。</p><p>用 Python 实现后端 API 的封装，主要包括以下几步：</p><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> ResNet50</span><br><span class="line"></span><br><span class="line">model = ResNet50(weights=<span class="string">"imagenet"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="图片预处理"><a href="#图片预处理" class="headerlink" title="图片预处理"></a>图片预处理</h3><p>ResNet50 模型的默认输入尺寸是 224x224 像素，输入格式为 RGB，故需要对输入图片做一些预处理：</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.image <span class="keyword">import</span> img_to_array</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> imagenet_utils</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare_image</span><span class="params">(image, target)</span>:</span></span><br><span class="line">    <span class="comment"># if the image mode is not RGB, convert it</span></span><br><span class="line">    <span class="keyword">if</span> image.mode != <span class="string">"RGB"</span>:</span><br><span class="line">        image = image.convert(<span class="string">"RGB"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># resize the input image and preprocess it</span></span><br><span class="line">    image = image.resize(target)</span><br><span class="line">    image = img_to_array(image)</span><br><span class="line">    image = np.expand_dims(image, axis=<span class="number">0</span>)</span><br><span class="line">    image = imagenet_utils.preprocess_input(image)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></tbody></table></figure><h3 id="创建RESTful-API"><a href="#创建RESTful-API" class="headerlink" title="创建RESTful API"></a>创建 RESTful API</h3><p><a href="https://github.com/pallets/flask" target="_blank" rel="noopener">Flask</a> 是一个轻量级的 Python Web 应用框架，用 Flask 创建一个 POST 接口，用于接收客户端传过来的图片文件，送入模型进行识别，然后把识别结果返回给客户端。</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/predict", methods=["POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">()</span>:</span></span><br><span class="line">    data = {<span class="string">"success"</span>: <span class="keyword">False</span>}</span><br><span class="line">    <span class="keyword">if</span> request.files.get(<span class="string">"image"</span>):</span><br><span class="line">        image = request.files[<span class="string">"image"</span>].read()</span><br><span class="line">        image = Image.open(io.BytesIO(image))</span><br><span class="line">        image = prepare_image(image, target=(<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"></span><br><span class="line">        preds = model.predict(image)</span><br><span class="line">        results = imagenet_utils.decode_predictions(preds)</span><br><span class="line"></span><br><span class="line">        data[<span class="string">"predictions"</span>] = []</span><br><span class="line">        <span class="keyword">for</span> (_, label, prob) <span class="keyword">in</span> results[<span class="number">0</span>]:</span><br><span class="line">            r = {<span class="string">"label"</span>: label, <span class="string">"probability"</span>: float(prob)}</span><br><span class="line">            data[<span class="string">"predictions"</span>].append(r)</span><br><span class="line">        data[<span class="string">"success"</span>] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> jsonify(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="Vue客户端"><a href="#Vue客户端" class="headerlink" title="Vue客户端"></a>Vue 客户端</h2><p>用 Vue.js 开发一个 Web 客户端，实现图片上传和识别结果展示。</p><p>为了贯彻 Vue 组件化开发思想，我把单一页面分成三个子组件，分别是图片选择、图片预览和结果显示三个组件，然后放置在一个父组件中，组件间通过 Vuex 共享状态。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>首先从电脑硬盘中选取一张图片，组件获取图片后，提交 mutation 更新 store 中的状态，把图片 URL 传递给预览组件：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">getFile(event) {</span><br><span class="line">  <span class="keyword">let</span> image = event.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> imgurl = <span class="built_in">window</span>.URL.createObjectURL(image);</span><br><span class="line">  <span class="keyword">this</span>.$store.commit(<span class="string">"updateData"</span>, {</span><br><span class="line">    img: imgurl,</span><br><span class="line">    ifsucc: <span class="number">1</span></span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">this</span>.postimg(image);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时请求 Flask 服务端接口，并把返回结果传递给图表子组件：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fdata = <span class="keyword">new</span> FormData();</span><br><span class="line">fdata.append(<span class="string">"image"</span>, image);</span><br><span class="line"><span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">axios.post(<span class="string">"/predict"</span>, fdata, {</span><br><span class="line">    headers: { <span class="string">"Content-Type"</span>: <span class="string">"multipart/form-data"</span> }</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (res.data.success) {</span><br><span class="line">      _this.$store.commit(<span class="string">"updateData"</span>, {</span><br><span class="line">        ifsucc: <span class="number">2</span>,</span><br><span class="line">        possblity: res.data.predictions</span><br><span class="line">      });</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      _this.$store.commit(<span class="string">"updateData"</span>, {</span><br><span class="line">        ifsucc: <span class="number">3</span>,</span><br><span class="line">        msg: <span class="string">"图片无法识别"</span></span><br><span class="line">      });</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> {</span><br><span class="line">    _this.$store.commit(<span class="string">"updateData"</span>, {</span><br><span class="line">      ifsucc: <span class="number">4</span>,</span><br><span class="line">      msg: error.toString()</span><br><span class="line">    });</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><h3 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h3><p>这里我已将前后端整体打包为一个 <a href="https://hub.docker.com/r/yunterry/keras-vue" target="_blank" rel="noopener">Docker 镜像</a>，你可以直接运行一个 Docker 容器来体验：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">docker run -p 80:80 yunterry/keras-vue</span><br></pre></td></tr></tbody></table></figure><p>前端页面：</p><p><img src="/pic/keras/kv-1.jpg" alt=""></p><h2 id="Android客户端"><a href="#Android客户端" class="headerlink" title="Android客户端"></a>Android 客户端</h2><p>通过 Android 客户端你可以直接用手机摄像头拍摄一张照片，或是从手机相册中选取一张照片进行识别，这里用 Retrofit、Picasso 开发一个 Android APP。</p><h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><p>先从手机相册中选取一张图片，显示在图片预览控件中：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String imgpath = data.getStringArrayListExtra(</span><br><span class="line">        MultiImageSelectorActivity.EXTRA_RESULT).get(<span class="number">0</span>);</span><br><span class="line">Picasso.with(<span class="keyword">this</span>).load(<span class="string">"file://"</span> + imgpath).into(imgView);</span><br></pre></td></tr></tbody></table></figure><p>同时向服务端发起 Post 请求，把图片传过去，请求返回即为识别结果，根据标签和概率显示在列表控件中:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Rest.getRestApi().uploadFile(requestImgPart)</span><br><span class="line">    .enqueue(<span class="keyword">new</span> Callback&lt;Result&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;Result&gt; call, Response&lt;Result&gt; response)</span> </span>{</span><br><span class="line">        recyclerView.setAdapter(<span class="keyword">new</span> CommonAdapter&lt;Result.PredictionsBean&gt;(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                R.layout.img_item, response.body().predictions) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(ViewHolder holder, Result.PredictionsBean pred, <span class="keyword">int</span> position)</span> </span>{</span><br><span class="line">                holder.setProgress(R.id.progress, (<span class="keyword">int</span>) Math.round(pred.probability * <span class="number">10000</span>));</span><br><span class="line">                holder.setText(R.id.object, pred.label);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;Result&gt; call, Throwable t)</span> </span>{</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"请求失败"</span>,</span><br><span class="line">                Toast.LENGTH_LONG).show();</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><p><img src="/pic/keras/kv-2.jpg" alt=""></p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><h3 id="Vue客户端-1"><a href="#Vue客户端-1" class="headerlink" title="Vue客户端"></a>Vue 客户端</h3><p><a href="https://github.com/yunTerry/Keras-Vue" target="_blank" rel="noopener">https://github.com/yunTerry/Keras-Vue</a></p><h3 id="Android客户端-1"><a href="#Android客户端-1" class="headerlink" title="Android客户端"></a>Android 客户端</h3><p><a href="https://github.com/yunTerry/Keras-Android" target="_blank" rel="noopener">https://github.com/yunTerry/Keras-Android</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.keras.io" target="_blank" rel="noopener">https://blog.keras.io</a></p>]]></content><categories><category>人工智能</category></categories><tags><tag>Android</tag><tag>Keras</tag><tag>TensorFlow</tag><tag>人工智能</tag><tag>Vue</tag></tags></entry><entry><title>Spring Cloud 分布式微服务实践</title><url>/springcloud/</url><content><![CDATA[<h2 id="Spring-Cloud微服务框架"><a href="#Spring-Cloud微服务框架" class="headerlink" title="Spring Cloud微服务框架"></a>Spring Cloud 微服务框架</h2><p>Spring Cloud 是基于 Netflix 等公司大量的微服务实践，封装出的一整套微服务开发框架，主要包括微服务网关、服务注册中心、配置中心、远程调用、负载均衡、<a id="more"></a>消息总线、容错断路、监控追踪等模块，为开发高可用、高可扩展性的分布式应用提供了一套易用的解决方案。</p><p>Spring Cloud 的微服务组件基于 Spring Boot 开发，可以说 Spring Boot 是 Spring Cloud 的基石。</p><p>Spring Boot 通过自动配置等功能极大地简化了 Spring 应用的开发，提升了开发效率，同时支持内嵌 Tomcat（以及 Jetty、Undertow）等 Servlet 容器，打包部署更加方便。</p><p>前不久刚刚发布了 SpringBoot 2.0 版本，该版本最大特点是将响应式编程作为首选的编程范式，支持 WebFlux、RxJava，更易于实现异步和事件驱动，创建完全非阻塞式应用。</p><h2 id="分布式微服务实践"><a href="#分布式微服务实践" class="headerlink" title="分布式微服务实践"></a>分布式微服务实践</h2><p>这里我们基于 Spring Cloud 开发一个分布式应用，主要用到 Eureka 服务注册发现、Config 配置中心、Feign 做服务调用、Zuul 微服务网关、Hystrix 服务容错降级、Admin 服务管控、Zipkin 服务链路追踪，具体包括以下几个微服务：</p><h3 id="注册中心-eureka-server"><a href="#注册中心-eureka-server" class="headerlink" title="注册中心 eureka-server"></a>注册中心 eureka-server</h3><p>启动应用后，打开 <a href="http://localhost:8761" target="_blank" rel="noopener">http://localhost:8761</a> 可以看到启动的服务实例</p><p><img src="/pic/cloud/1.jpg" alt=""></p><h3 id="配置中心-config-server"><a href="#配置中心-config-server" class="headerlink" title="配置中心 config-server"></a>配置中心 config-server</h3><p>该服务将 git 仓库中的配置文件以接口形式提供，客户端可以获取并加载配置。</p><p>例如获取 eureka 配置信息，打开 <a href="http://localhost:3600/eureka/default" target="_blank" rel="noopener">http://localhost:3600/eureka/default</a></p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"eureka"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"default"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"a716ea609caaa0811387bcc616227b42e6094b26"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"propertySources"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"https://github.com/yunTerry/spring-cloud-netflix/config-repo/eureka.yml"</span>,</span><br><span class="line">            <span class="attr">"source"</span>: {</span><br><span class="line">                <span class="attr">"spring.application.name"</span>: <span class="string">"eureka-server"</span>,</span><br><span class="line">                <span class="attr">"server.port"</span>: <span class="number">8761</span>,</span><br><span class="line">                <span class="attr">"eureka.client.register-with-eureka"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"eureka.client.fetch-registry"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"management.security.enabled"</span>: <span class="literal">false</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="微服务网关-Zuul"><a href="#微服务网关-Zuul" class="headerlink" title="微服务网关 Zuul"></a>微服务网关 Zuul</h3><p>用 serviceId 代替 URL，实现动态路由。</p><p>通过 Zuul 过滤器进行请求鉴权，拦截不合法请求</p><p>还可以在 Zuul 中实现 API 限流等操作，参考 <a href="https://yunterry.gitee.io/zuul-rate-limit">Spring Cloud Zuul 微服务网关的 API 限流</a>。</p><h3 id="服务生产者-token-service"><a href="#服务生产者-token-service" class="headerlink" title="服务生产者 token-service"></a>服务生产者 token-service</h3><p>Token 认证相关服务，提供生成 token 和验证 token 的接口</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/token/generate/{uid}"</span>)</span><br><span class="line"><span class="function">String <span class="title">getToken</span><span class="params">(@PathVariable String uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/token/verify"</span>)</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(@RequestParam String token)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="服务消费者-user-service"><a href="#服务消费者-user-service" class="headerlink" title="服务消费者 user-service"></a>服务消费者 user-service</h3><p>调用用户相关服务的时候，会消费 token 认证服务，使用 Feign 调用服务，通过 Hystrix 提供容错保护</p><p>向 <a href="http://localhost:4000/user-service/login" target="_blank" rel="noopener">http://localhost:4000/user-service/login</a> 发 POST 请求</p><p>登录或注册成功返回 token</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"login success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="string">"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiI3NjVhNWEyYy1hYzhhLTQxNDctYjI2Yy0zNTFlYTA0NjI4OGEiLCJleHAiOjE1MjA1OTMzODF9.NMUjrRk7MsAROuq1OLOUM9WOefgkZmg5_M_mjiSVa0Cz-SunY2ucgxEvOGdKW7U1AVteNVVtD1v_cQlwA_wREQ"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>把 token 放在请求头，获取用户信息 <a href="http://localhost:4000/user-service/user/info" target="_blank" rel="noopener">http://localhost:4000/user-service/user/info</a></p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: {</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"765a5a2c-ac8a-4147-b26c-351ea046288a"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"aa"</span>,</span><br><span class="line">        <span class="attr">"sex"</span>: <span class="string">"boy"</span>,</span><br><span class="line">        <span class="attr">"img"</span>: <span class="string">"http://img.com/aa32.jpg"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">20</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="服务管控-admin-server"><a href="#服务管控-admin-server" class="headerlink" title="服务管控 admin-server"></a>服务管控 admin-server</h3><p>打开 <a href="http://localhost:5033" target="_blank" rel="noopener">http://localhost:5033</a></p><p>进入服务管理界面，查看服务运行状态</p><p><img src="/pic/cloud/2.jpg" alt=""></p><p><img src="/pic/cloud/3.jpg" alt=""></p><h3 id="服务链路追踪-Zipkin"><a href="#服务链路追踪-Zipkin" class="headerlink" title="服务链路追踪 Zipkin"></a>服务链路追踪 Zipkin</h3><p>在 <a href="http://localhost:5500/zipkin/" target="_blank" rel="noopener">http://localhost:5500/zipkin/</a> 可以查看服务调用链路</p><p><img src="/pic/cloud/4.jpg" alt=""></p><p>服务调用时间</p><p><img src="/pic/cloud/5.jpg" alt=""></p><p>调用详情</p><p><img src="/pic/cloud/6.jpg" alt=""></p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p><a href="https://github.com/yunTerry/spring-cloud-netflix" target="_blank" rel="noopener">https://github.com/yunTerry/spring-cloud-netflix</a></p>]]></content><categories><category>Java</category></categories><tags><tag>Spring Cloud</tag><tag>SpringBoot</tag><tag>服务发现</tag><tag>微服务</tag></tags></entry><entry><title>聊聊微服务架构</title><url>/microservice/</url><content><![CDATA[<h2 id="微服务概述"><a href="#微服务概述" class="headerlink" title="微服务概述"></a>微服务概述</h2><p>微服务，顾名思义微小的服务，当传统的单体应用规模和复杂度达到一定程度的时候，应用的管理、扩展、可靠性等方面就会出现瓶颈，一个基本原则就是分而治之，把一个大的复杂应用拆分成多个小的服务，让每个小服务可以单独进行管理、扩展，微服务由此演化而来。</p><p><img src="/pic/micro/mcr.jpg" alt=""><a id="more"></a></p><p>微服务强调拆分后服务的独立性，麻雀虽小，五脏俱全，每个微服务有自己独立的数据库，有自己的业务实现，各自运行在独立的进程中，对外提供设计好的接口，服务间去耦合，通过 RPC、HTTP 等协议进行远程交互，服务内部功能可以使用任意语言和框架实现，对外是不可见的。</p><h2 id="微服务架构特点"><a href="#微服务架构特点" class="headerlink" title="微服务架构特点"></a>微服务架构特点</h2><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>传统的单体应用只有一个服务，这个服务就是系统的中心，而微服务架构是去中心化的，把复杂的系统拆分成多个简单的分布式组件，每个组件都是服务化的，能够独立部署独立升级。</p><p>除了业务逻辑去中心化，数据同样也要去中心化，微服务要有自己独有的数据库，每个服务只对自己的数据负责，也不允许直接读写别人的数据库，就像自家的资产只能自己处置，别人不能随便动。</p><h3 id="专注做好一件事"><a href="#专注做好一件事" class="headerlink" title="专注做好一件事"></a>专注做好一件事</h3><p>微服务架构的关键在于业务功能的合理拆分，以最终实现分布式系统的高内聚、低耦合，如果拆分不合理还会导致后期代码维护和功能扩展越发困难。</p><p>通常架构设计时尽可能使每个微服务专注做好一件事，合理划分服务边界，使数据结构易于独立，对外接口简洁通用，一个好的设计理念就是领域驱动设计 (Domain Driven Design)，根据领域的边界设计服务范畴。</p><h3 id="技术多样性"><a href="#技术多样性" class="headerlink" title="技术多样性"></a>技术多样性</h3><p>单体应用通常只能采用单一语言开发，但每种编程语言都有各自优势，协作团队中通常每个人都有各自擅长的语言框架，单体应用限制了这种自由，而在微服务系统中没有这些限制，各个服务相互独立，每个服务都可以用不同的编程语言实现，每个人都可以发挥自己的特长。</p><p><img src="/pic/micro/lang.jpg" alt=""></p><p>事实上，技术的多样性对一个系统的健壮性也大有裨益，除了可以发挥多种语言框架的优势，还可以逐步引入新技术，有利于系统的演进升级。</p><h3 id="服务容错保护"><a href="#服务容错保护" class="headerlink" title="服务容错保护"></a>服务容错保护</h3><p>我们知道在分布式系统中，节点失效应被视作常态而不是意外，即节点失效是一定会发生的，要实现系统高可用，必须要提前做好预备措施。微服务体系中，由于服务间错综复杂的依赖关系，一套完整的服务往往有很长的调用链路，对微服务进行容错降级是很有必要的，当某个服务实例出错时及时进行降级、隔离，既能提高响应速度，还能防止请求积压造成雪崩。</p><p>服务容错保护和业内常提的异地多活、Design For Failure 等思想一脉相承，一方面是服务提供方的多实例冗余，另一方面是服务消费方的降级保护，都是为分布式系统的高可用所做的预备措施。</p><p>当然任何系统都很难保证绝对可用，前不久就连 AWS 和 Google Cloud 都发生过服务中断事件，它们在服务高可用方面是业内首屈一指的，但仍然会发生事故，因此我们只能通过各种容错手段尽量避免此类事件发生。</p><h3 id="开发运维一体化"><a href="#开发运维一体化" class="headerlink" title="开发运维一体化"></a>开发运维一体化</h3><p>开发运维一体化即流行的 DevOps，谁开发的谁运维，这样开发人员能更快地响应业务需求，更好地保障服务后续运行和升级，同时避免团队间大量的无效沟通和摩擦。</p><p>现在流行的各种 CI/CD、自动化运维技术也在促进开发运维一体化。</p><h3 id="拥抱容器技术"><a href="#拥抱容器技术" class="headerlink" title="拥抱容器技术"></a>拥抱容器技术</h3><p>有人说容器和微服务简直是天生一对，容器的轻巧高效恰好匹配微服务的灵活多变，结合 Docker 容器技术和微服务架构有助于应用的持续集成、持续交付和持续部署，目前备受追捧的云原生技术就是直接把微服务构建在容器基础设施上。</p><p>随着 Kubernetes 等容器基础设施的日趋成熟，容器逐渐成为微服务的标准载体，在容器基础设施上构建运行高可用、高可扩展的微服务将越来越简单。</p><h2 id="微服务的挑战"><a href="#微服务的挑战" class="headerlink" title="微服务的挑战"></a>微服务的挑战</h2><p>微服务作为近年来流行的软件架构风格，它能帮助我们实现系统的高可用和高可扩展性，但微服务也会有各种挑战。</p><h3 id="应用的挑战"><a href="#应用的挑战" class="headerlink" title="应用的挑战"></a>应用的挑战</h3><ul><li><p>由于微服务将整个系统进行拆分，所以系统的架构、开发工作量和复杂度会增加不少</p></li><li><p>原来的单体应用变成一系列微服务，就要花费更多精力去管理和协调这些服务，系统的运维复杂度会增加不少</p></li><li><p>原来调用的本地方法变成了服务间的远程调用，可能会使系统性能有所降低，这意味着要增加硬件投入</p></li></ul><h3 id="架构的挑战"><a href="#架构的挑战" class="headerlink" title="架构的挑战"></a>架构的挑战</h3><p>除了应用中的挑战，微服务架构本身也面临挑战，根据 CAP 理论，在分布式系统中数据一致性 (Consistency)、服务可用性 (Availability)、分区容忍性 (Partition tolerance) 三者不可能同时满足，最多只能实现其中两点，那么如何根据业务特点做出最佳权衡和取舍，就是微服务架构面临的挑战。</p><p><img src="/pic/micro/cap.png" alt=""></p><p>孟老夫子说过鱼和熊掌不可兼得，则舍鱼而取熊掌者也。在分布式系统中，分区容忍是必须要满足的，所以一般在一致性和可用性之间进行权衡，要么舍弃部分一致性，追求高可用；要么严格强调一致性，损失部分高可用。</p><p>到底是高可用重要还是一致性重要，这在服务注册中心也对应着两种流派：一种是 Eureka 为代表的 AP 流派，强调高可用，弱化一致性；另一种是 CP 流派，典型的就是 ZooKeeper 这类注册中心，为保证强一致性，在某些时候（如 leader 选举期间）会牺牲可用性。</p><p>一种常用的折中方案就是 BASE 原则，它是指基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventual Consistency），也就是放弃强一致性，获得较好的可用性，允许节点间有暂时的不一致，只要最终一致就行了。</p><p>实际应用中要根据系统对高可用和一致性等各方面的要求程度，做出适当的权衡和取舍，比如在社交媒体应用中高可用比强一致更重要，而在金融交易系统中则必须保证强一致性。</p><h2 id="是否采用微服务"><a href="#是否采用微服务" class="headerlink" title="是否采用微服务"></a>是否采用微服务</h2><p>对一个系统来讲，架构是逐步演进的，是否采用微服务架构要根据具体的团队和业务情况来定，一般来讲，如果团队规模和业务复杂度达到一定程度，单体应用已经力不从心的时候就该上微服务了。</p>]]></content><categories><category>云计算</category></categories><tags><tag>微服务</tag></tags></entry><entry><title>SQL 将关系数据库表转 Java 对象</title><url>/sql2java/</url><content><![CDATA[<p>最近用 SpringBoot 重构一个 PHP 项目，用 JPA 操作 MySQL 数据库，由于要维持原来的表结构，应用中要把许多表转化为 Java 类。</p><p><img src="/pic/sql/sql.jpg" alt=""><a id="more"></a></p><p>一般的 ORM 框架可以很方便地把 Java 类映射为关系数据库表，但这里显然是它的逆过程，这个好像没有现成的工具和框架，难道要对着表一个字段一个字段地写？</p><p><img src="/pic/sql/tan90.jpg" alt=""></p><p>要知道，数据库有几十张表，每张表都有很多字段，一个个写还真得花不少精力，而且手写还很容易出错。</p><p>最好的办法当然是用程序实现自动转换了，这里我们用 SQL 来实现这种转换。</p><h2 id="SQL实现表转Java"><a href="#SQL实现表转Java" class="headerlink" title="SQL实现表转Java"></a>SQL 实现表转 Java</h2><p>基本思路就是根据表名查询出列名，用 concat 函数拼接修饰符得到 Java 对象属性列表：</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="string">'public  '</span>, <span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'varchar'</span>, <span class="string">'char'</span>, <span class="string">'text'</span>) <span class="keyword">THEN</span> <span class="string">'String'</span></span><br><span class="line">    <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'int'</span>, <span class="string">'tinyint'</span>) <span class="keyword">THEN</span> <span class="string">'Integer'</span></span><br><span class="line">    <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'bigint'</span>) <span class="keyword">THEN</span> <span class="string">'Long'</span></span><br><span class="line">    <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'datetime'</span>) <span class="keyword">THEN</span> <span class="string">'Date'</span></span><br><span class="line">    <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'bit'</span>, <span class="string">'boolean'</span>) <span class="keyword">THEN</span> <span class="string">'Boolean'</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">'类型不确定'</span></span><br><span class="line">  <span class="keyword">END</span>, <span class="string">'  '</span>, column_name, <span class="string">';'</span>) <span class="keyword">AS</span> <span class="keyword">java</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.columns</span><br><span class="line"><span class="keyword">WHERE</span> table_name = <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure><p>运行结果就是转换好的 Java 对象属性了，直接复制到类中即可。</p><h2 id="封装成-MySQL-存储过程"><a href="#封装成-MySQL-存储过程" class="headerlink" title="封装成 MySQL 存储过程"></a>封装成 MySQL 存储过程</h2><p>把上面 SQL 语句封装成存储过程，使用的时候更方便：</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 以表名为输入参数，输出对应的java对象属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sql2java (</span><br><span class="line">  <span class="keyword">IN</span> t_name <span class="built_in">char</span>(<span class="number">30</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="string">'public  '</span>, <span class="keyword">CASE</span> </span><br><span class="line">      <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'varchar'</span>, <span class="string">'char'</span>, <span class="string">'text'</span>) <span class="keyword">THEN</span> <span class="string">'String'</span></span><br><span class="line">      <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'int'</span>, <span class="string">'tinyint'</span>) <span class="keyword">THEN</span> <span class="string">'Integer'</span></span><br><span class="line">      <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'bigint'</span>) <span class="keyword">THEN</span> <span class="string">'Long'</span></span><br><span class="line">      <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'datetime'</span>) <span class="keyword">THEN</span> <span class="string">'Date'</span></span><br><span class="line">      <span class="keyword">WHEN</span> data_type <span class="keyword">IN</span> (<span class="string">'bit'</span>, <span class="string">'boolean'</span>) <span class="keyword">THEN</span> <span class="string">'Boolean'</span></span><br><span class="line">      <span class="keyword">ELSE</span> <span class="string">'类型不确定'</span></span><br><span class="line">    <span class="keyword">END</span>, <span class="string">'  '</span>, column_name, <span class="string">';'</span>) <span class="keyword">AS</span> <span class="keyword">java</span></span><br><span class="line">  <span class="keyword">FROM</span> information_schema.columns</span><br><span class="line">  <span class="keyword">WHERE</span> table_name = t_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure><p>调用 MySQL 存储过程，直接传入表名即可：</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sql2java(<span class="string">'person'</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="循环遍历所有表"><a href="#循环遍历所有表" class="headerlink" title="循环遍历所有表"></a>循环遍历所有表</h2><p>数据库中有很多张表，如果我们不想一次次输入表名，通过循环遍历可以一次性得到所有结果。</p><p>具体做法是先查出数据库所有表名：</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table_name</span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> table_schema = <span class="string">'db_name'</span>;</span><br></pre></td></tr></tbody></table></figure><p>然后把结果集通过游标和 while 循环遍历所有表：</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line">open cur;</span><br><span class="line"></span><br><span class="line">while done <span class="keyword">do</span></span><br><span class="line">   <span class="comment">-- 获取数据</span></span><br><span class="line">   <span class="keyword">fetch</span> cur <span class="keyword">into</span> t_name;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">-- 直接调用之前的存储过程</span></span><br><span class="line">   <span class="keyword">call</span> sql2java (t_name);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line">close cur;</span><br></pre></td></tr></tbody></table></figure><p>最后把上面 SQL 语句封装成 sql2java_all 存储过程。</p><p>调用存储过程，可一次性输出所有表的 Java 类：</p><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sql2java_all;</span><br></pre></td></tr></tbody></table></figure><p>此方法除了可以得到 Java 类，稍作修改也可以支持多语言，比如 Python、PHP 的类，C++、Golang 的结构体以及 Protobuf 的 DSL 代码。</p><h2 id="本文SQL源码"><a href="#本文SQL源码" class="headerlink" title="本文SQL源码"></a>本文 SQL 源码</h2><p><a href="https://github.com/yunTerry/SQL2Java" target="_blank" rel="noopener">https://github.com/yunTerry/SQL2Java</a></p>]]></content><categories><category>Java</category></categories><tags><tag>MySQL</tag><tag>ORM</tag></tags></entry><entry><title>Docker Compose 轻量级容器编排</title><url>/docker-compose/</url><content><![CDATA[<p><em>使用 Docker Compose 编排 Spring Cloud 分布式应用。</em></p><p><img src="/pic/docker/compose.jpg" alt=""><a id="more"></a></p><p>说到容器编排，目前很火的 Kubernetes 就是一个自动化容器编排工具，但 Kubernetes 是一个重量级选手，部署比较复杂，对于简单的分布式应用，可以使用 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">Docker Compose</a> 做轻量级的容器编排，实现容器间的服务注册发现和弹性伸缩。</p><h2 id="Spring-Cloud分布式应用"><a href="#Spring-Cloud分布式应用" class="headerlink" title="Spring Cloud分布式应用"></a>Spring Cloud 分布式应用</h2><p>这里用 Spring Cloud 开发一个简单的分布式应用，该应用包含几个简单的微服务：Eureka 做服务注册发现，Feign 服务调用，Zuul 微服务网关，Ribbon 负载均衡，Hystrix 服务降级 / 隔离。</p><p>把微服务放在 Docker 容器内，用 compose 进行容器自动化构建和部署，实现基本的注册中心、服务调用、路由和监控。</p><h2 id="Docker-compose容器编排"><a href="#Docker-compose容器编排" class="headerlink" title="Docker compose容器编排"></a>Docker compose 容器编排</h2><p>Docker compose 是一个容器管理工具，可以很方便地构建和管理多容器应用。</p><h3 id="构建运行容器"><a href="#构建运行容器" class="headerlink" title="构建运行容器"></a>构建运行容器</h3><p>在 docker-compose.yml 中配置容器编排规则：<br></p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  eureka:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">eureka</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8000</span><span class="string">:80</span></span><br><span class="line"><span class="attr">  provider:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">service-provider</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">service-provider</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  consumer:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">feign-consumer</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">feign-consumer</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  gateway:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">zuul-gateway</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">zuul-gateway</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">hystrix-turbine</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">hystrix-turbine</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>为了加快构建速度，需要先编译出 jar 文件，再统一构建和运行：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 编译SpringBoot</span></span><br><span class="line">mvn clean package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建Docker镜像</span></span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行所有容器</span></span><br><span class="line">docker-compose up</span><br></pre></td></tr></tbody></table></figure><p>Docker 容器内是一个封闭环境，容器内服务间可通过 Docker compose 中的服务名直接互联。</p><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>Eureka 注册中心服务映射到容器外 8000 端口，打开注册中心可以看到服务都已启动：</p><p><img src="/pic/docker/compose-1.jpg" alt=""></p><h3 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API 网关</h3><p>Zuul 网关映射到容器外 80 端口，通过 Zuul 可以访问到容器内的服务。</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 停止所有微服务</span></span><br><span class="line">docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line">docker-compose rm</span><br></pre></td></tr></tbody></table></figure><h2 id="服务扩容"><a href="#服务扩容" class="headerlink" title="服务扩容"></a>服务扩容</h2><p>微服务架构中，我们经常需要对服务进行扩容缩容，docker-compose scale 可以指定服务启动多少个实例，方便实现系统的弹性伸缩。</p><p>比如要启动 3 个 provider 和两个 gateway 实例，执行一条命令：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">docker-compose scale provider=3 gateway=2</span><br></pre></td></tr></tbody></table></figure><p>执行完成后打开注册中心，可以看到已经启动了 3 个 provider 和两个 gateway 实例：</p><p><img src="/pic/docker/compose-2.jpg" alt=""></p><h2 id="清理中间镜像"><a href="#清理中间镜像" class="headerlink" title="清理中间镜像"></a>清理中间镜像</h2><p>构建镜像后，如果之前有同名镜像，会出现一些标签为空的镜像：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                  TAG             IMAGE ID            CREATED              SIZE</span><br><span class="line">yunterry/service-provider   latest          088d56298e08        About a minute ago   144MB</span><br><span class="line">yunterry/feign-consumer     latest          5e04a653948a        About a minute ago   147MB</span><br><span class="line">yunterry/zuul-gateway       latest          160c477c3909        About a minute ago   148MB</span><br><span class="line">yunterry/hystrix-turbine    latest          e61c005e7740        About a minute ago   148MB</span><br><span class="line">yunterry/eureka             latest          a58a9dfdfe24        About a minute ago   148MB</span><br><span class="line">&lt;none&gt;                      &lt;none&gt;          70c9ad8823b9        2 days ago           148MB</span><br><span class="line">&lt;none&gt;                      &lt;none&gt;          d331346e70a7        2 days ago           149MB</span><br><span class="line">&lt;none&gt;                      &lt;none&gt;          a3dafb3c5d70        2 days ago           148MB</span><br><span class="line">&lt;none&gt;                      &lt;none&gt;          e5c3078fe57c        2 days ago           145MB</span><br><span class="line">&lt;none&gt;                      &lt;none&gt;          fc30ccb5ff6d        2 days ago           150MB</span><br><span class="line">consul                      latest          d686c08d0dc8        11 days ago          51.8MB</span><br><span class="line">node                        alpine          a47a5669ac57        3 weeks ago          65.3MB</span><br><span class="line">redis                       latest          1fb7b6c8c0d0        3 weeks ago          107MB</span><br><span class="line">muli/gluon-tutorials-zh     latest          1e80c558f4a8        5 weeks ago          2.15GB</span><br><span class="line">java                        jre-alpine      fdc893b19a14        8 months ago         108MB</span><br></pre></td></tr></tbody></table></figure><p>可以通过过滤器查看标签为空的镜像：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">$ docker images -f <span class="string">"dangling=true"</span></span><br><span class="line">REPOSITORY     TAG         IMAGE ID            CREATED         SIZE</span><br><span class="line">&lt;none&gt;         &lt;none&gt;      70c9ad8823b9        2 days ago      148MB</span><br><span class="line">&lt;none&gt;         &lt;none&gt;      d331346e70a7        2 days ago      149MB</span><br><span class="line">&lt;none&gt;         &lt;none&gt;      a3dafb3c5d70        2 days ago      148MB</span><br><span class="line">&lt;none&gt;         &lt;none&gt;      e5c3078fe57c        2 days ago      145MB</span><br><span class="line">&lt;none&gt;         &lt;none&gt;      fc30ccb5ff6d        2 days ago      150MB</span><br></pre></td></tr></tbody></table></figure><p>所以清理这些中间镜像就很简单了，取出这些标签为空的镜像 ID，就可以批量删除：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">docker rmi $(docker images -f <span class="string">"dangling=true"</span> -q)</span><br></pre></td></tr></tbody></table></figure><p>再用 docker images 查看就很整洁了。</p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p><a href="https://github.com/yunTerry/Spring-Cloud-Docker" target="_blank" rel="noopener">https://github.com/yunTerry/Spring-Cloud-Docker</a></p>]]></content><categories><category>容器</category></categories><tags><tag>Spring Cloud</tag><tag>Docker</tag><tag>微服务</tag></tags></entry><entry><title>RESTful API 使用 JWT 做无状态的身份认证</title><url>/rest-jwt/</url><content><![CDATA[<h2 id="JWT设计"><a href="#JWT设计" class="headerlink" title="JWT设计"></a>JWT 设计</h2><p>RESTful 架构的前后端，经常会使用 Token 令牌做身份验证，<a href="https://jwt.io/" target="_blank" rel="noopener">JWT(JSON Web Token)</a> 是一种简单易用的 Token 标准，适合在应用中做无状态的 API 身份认证。</p><p><img src="/pic/jwt/jwt-1.jpg" alt=""><a id="more"></a></p><p>jwt 由 Header、Payload、Signature 三部分组成，使用<code>.</code> 分割开，一个 JWT 形式：<br></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></tbody></table></figure><p></p><p>这三部分分别对应的是加密算法、携带的用户信息、加密后的字符串（签名）。</p><p>Jwt 自带签名，能够防止伪造或篡改，但要防止 token 被窃取还要配合 https 使用。</p><p>下面我们用 Jwt 开发一个前后端交互系统。</p><h2 id="JWT服务端"><a href="#JWT服务端" class="headerlink" title="JWT服务端"></a>JWT 服务端</h2><p>这里使用 <strong><a href="https://github.com/jwtk/jjwt" target="_blank" rel="noopener">jjwt</a></strong> 开源库生成 token</p><h3 id="创建RESTful接口"><a href="#创建RESTful接口" class="headerlink" title="创建RESTful接口"></a>创建 RESTful 接口</h3><p>Server 端基于 SpringBoot 开发，提供生成 token 和校验 token 的接口：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function">Back <span class="title">login</span><span class="params">(@RequestParam String name,</span></span></span><br><span class="line"><span class="function"><span class="params">           @RequestParam String pwd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function">Back <span class="title">getUser</span><span class="params">(@RequestHeader String jwt)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>登录或注册接口：客户端提交用户名密码，服务端完成登录或注册逻辑，然后生成 jwt 令牌并返回给客户端</p></li><li><p>用户信息接口：客户端将 token 放在请求头，服务端校验是否合法，然后再从 MySQL 中查询并返回用户信息</p></li><li><p>服务端无需存储 jwt 令牌，通过特定的算法和密钥校验 token，同时取出 Payload 中携带的用户 ID，减少不必要的数据库查询</p></li><li><p>本例中设置 jwt 有效期为 3 天，服务端每次都会自动校验 token 是否过期，如果过期就直接抛出异常，客户端需要重新申请 token</p></li></ul><h3 id="Token统一校验"><a href="#Token统一校验" class="headerlink" title="Token统一校验"></a>Token 统一校验</h3><p>业务相关接口一般都需要 token 验证，这就应该把验证逻辑放在一个统一的切面层完成，Spring 的 AOP 正好满足这一需要。</p><p>这里实现 Spring 的拦截器 HandlerInterceptor 接口，在 Controller 方法执行之前拦截需要鉴权的请求，验证 token 是否合法，合法就放行，不合法则直接抛出异常拦截请求。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> </span>{</span><br><span class="line">        <span class="comment">//在请求处理之前校验token</span></span><br><span class="line">        String token = httpServletRequest.getHeader(<span class="string">"jwt"</span>);</span><br><span class="line">        <span class="keyword">return</span> Util.verify(token);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后在 WebMvcConfigurerAdapter 中添加此拦截器，就可以实现 Token 统一校验了。</p><h2 id="JWT客户端"><a href="#JWT客户端" class="headerlink" title="JWT客户端"></a>JWT 客户端</h2><p>Android 客户端使用 Retrofit 做 REST 请求。</p><ul><li>登录或注册接口：提交用户名密码，服务端返回 jwt 令牌：</li></ul><p><img src="/pic/jwt/jwt-2.jpg" alt=""></p><ul><li><p>用户信息接口：客户端将 token 放在请求头，服务端校验通过即返回用户信息</p></li><li><p>客户端在本地存储 token 以后就能免登陆</p></li></ul><h2 id="JWT的缺陷"><a href="#JWT的缺陷" class="headerlink" title="JWT的缺陷"></a>JWT 的缺陷</h2><p>JWT 使用起来虽然简单方便，但它存在一个缺陷，即服务端无法主动注销 token，如果修改秘钥会让所有 token 失效，代价太大，通常只是被动等待 token 过期失效，所以 jwt 在安全性上不及 session，实际开发中应合理设置过期时间。</p><p>如果要让服务端能够注销 token，就要在服务端维护 token 状态，但这又回到 session 机制了。</p><p>JWT 这个缺陷决定了它更适合用在短期的 token 验证场景中，或者也可以结合 session 做长短期双重验证，弥补 session 的一些不足。</p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><h3 id="Jwt服务端"><a href="#Jwt服务端" class="headerlink" title="Jwt服务端"></a>Jwt 服务端</h3><p><a href="https://github.com/yunTerry/JWT-Server" target="_blank" rel="noopener">https://github.com/yunTerry/JWT-Server</a></p><h3 id="Jwt客户端"><a href="#Jwt客户端" class="headerlink" title="Jwt客户端"></a>Jwt 客户端</h3><p><a href="https://github.com/yunTerry/JWT-Android" target="_blank" rel="noopener">https://github.com/yunTerry/JWT-Android</a></p>]]></content><categories><category>Java</category></categories><tags><tag>Android</tag><tag>安全</tag><tag>SpringBoot</tag><tag>RESTful</tag></tags></entry><entry><title>Docker 容器的基本使用</title><url>/docker-intro/</url><content><![CDATA[<p>Docker 是用 go 语言开发的开源容器引擎，通过轻量级沙箱机制，让应用之间能够高效地隔离开来。</p><p><img src="/pic/docker/docker-0.jpg" alt=""><a id="more"></a></p><p>Docker 镜像将应用以集装箱形式打包，然后就能轻松部署到任意 Linux 服务器中，所以 Docker 容器技术极大地提升了软件交付效率。本文讲述在 Windows 系统上 Docker 容器的基本使用。</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker 安装</h2><p>Windows 系统安装 Docker Toolbox，安装完后，会有 Docker Quickstart Terminal 和 Kitematic 两个快捷方式。</p><p>Docker Quickstart Terminal 会进入命令行终端，Kitematic 是一个 Docker 的 GUI 工具，可以在图形界面管理 Docker 容器和镜像。</p><h2 id="常用的Docker命令"><a href="#常用的Docker命令" class="headerlink" title="常用的Docker命令"></a>常用的 Docker 命令</h2><p>进入 Docker Cli 终端执行常用的 Docker 命令，实现容器的 Build, Ship, Run 功能。</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line">docker pull centos</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure><p>docker images 查看本地镜像列表：</p><p><img src="/pic/docker/docker-1.jpg" alt=""></p><p>也可以在 Kitematic 中查看 Docker 镜像：</p><p><img src="/pic/docker/docker-2.jpg" alt=""></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 运行一个Docker容器</span></span><br><span class="line">docker run -d -p 9000:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内bash终端</span></span><br><span class="line">docker <span class="built_in">exec</span> -it badd967af535 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Docker容器</span></span><br><span class="line">docker stop badd967af535</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有容器</span></span><br><span class="line">docker stop $(docker ps -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除Docker镜像</span></span><br><span class="line">docker rmi a47a5669ac57</span><br></pre></td></tr></tbody></table></figure><h2 id="构建Docker镜像"><a href="#构建Docker镜像" class="headerlink" title="构建Docker镜像"></a>构建 Docker 镜像</h2><p>普通应用要构建为 Docker 镜像，需要一个 Dockerfile 文件，它是构建镜像的脚本文件，然后使用 docker build 命令构建镜像。</p><p>例如用 Node.js 搭建个人博客，然后构建成名为 node-blog 的镜像。</p><p>npm 的 package.json 配置：<br></p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"node-blog"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"Terry"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"My blog，built with Node.js，packaged into docker image"</span>,</span><br><span class="line">  <span class="attr">"repository"</span>: {</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/yunTerry/node-blog"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: {</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node app.js"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"dependencies"</span>: {</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"latest"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"Node.js"</span>,</span><br><span class="line">    <span class="string">"Docker"</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>只开启一个静态网页服务，应用主体 app.js 只有几行代码：<br></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/blog'</span>));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, () =&gt; {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'已启动 http://&lt;your-ip&gt;'</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p></p><p>编写 Dockerfile 文件：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">FROM node:lts-alpine</span><br><span class="line">MAINTAINER Terry &lt;2219569347@qq.com&gt;</span><br><span class="line"></span><br><span class="line">WORKDIR /terry</span><br><span class="line">COPY . .</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"npm"</span>,<span class="string">"start"</span>]</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></tbody></table></figure><p></p><p>构建 Docker 镜像：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">docker build -t yunterry/node-blog .</span><br></pre></td></tr></tbody></table></figure><p></p><p>构建完成后通过 docker images 可以看到该镜像。</p><h2 id="Docker-Hub镜像托管"><a href="#Docker-Hub镜像托管" class="headerlink" title="Docker Hub镜像托管"></a>Docker Hub 镜像托管</h2><p>Docker Hub 可以免费托管和分享 Docker 镜像，类似于 GitHub</p><p>把 node-blog 镜像 push 到 Docker Hub：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 登录Docker Hub</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传镜像</span></span><br><span class="line">docker push yunterry/node-blog</span><br></pre></td></tr></tbody></table></figure><p>然后在 Docker Hub 官网就可以搜到该镜像：</p><p><a href="https://hub.docker.com/r/yunterry/node-blog" target="_blank" rel="noopener">https://hub.docker.com/r/yunterry/node-blog</a></p><p><em>可以发现，Docker 镜像仓库的设计思想与 git 如出一辙，使用方法也基本类似。</em></p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>Docker 的好处是不用担心开发和生产环境不一致的问题，容器保证运行效果一致性，在另一台主机上运行博客镜像：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库下载镜像</span></span><br><span class="line">docker pull yunterry/node-blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行node-blog镜像</span></span><br><span class="line">docker run --rm -p 80:80 yunterry/node-blog</span><br></pre></td></tr></tbody></table></figure><p>浏览器打开 <a href="http://192.168.99.100" target="_blank" rel="noopener">http://192.168.99.100</a></p><p><img src="/pic/docker/docker-3.jpg" alt=""></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/yunTerry/node-blog" target="_blank" rel="noopener">https://github.com/yunTerry/node-blog</a></p>]]></content><categories><category>容器</category></categories><tags><tag>Docker</tag><tag>Node.js</tag></tags></entry><entry><title>Spring Cloud Zuul 微服务网关的 API 限流</title><url>/zuul-rate-limit/</url><content><![CDATA[<h2 id="API限流"><a href="#API限流" class="headerlink" title="API限流"></a>API 限流</h2><p>微服务开发中有时需要对 API 做限流保护，防止网络攻击，比如做一个短信验证码 API，限制客户端的请求速率能在一定程度上抵御短信轰炸攻击，降低损失。<a id="more"></a></p><p>微服务网关是每个请求的必经入口，非常适合做一些 API 限流、认证之类的操作，这里有一个基于 Zuul 微服务网关的 API 限流库：<a href="https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit" target="_blank" rel="noopener">https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>比如我们要对 <code>user-service</code> 这个服务进行限流，限制每个请求源每分钟最多只能请求 10 次。</p><p>首先在项目中添加 spring-cloud-zuul-ratelimit 依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.marcosbarbero.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-zuul-ratelimit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后再添加如下配置即可：</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  ratelimit:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    behind-proxy:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    policy-list:</span></span><br><span class="line"><span class="attr">      user-service:</span></span><br><span class="line"><span class="attr">        - limit:</span> <span class="number">10</span> </span><br><span class="line"><span class="attr">          refresh-interval:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">          type:</span> </span><br><span class="line"><span class="bullet">            -</span> <span class="string">user</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">origin</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">url</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>测试客户端如果 60s 内请求超过 10 次，服务端就抛出异常，一分钟后又可以正常请求</p></li><li><p>某个 IP 的客户端被限流并不影响其他客户端，即 API 网关对每个客户端限流是相互独立的</p></li></ul><h3 id="限流数据存储"><a href="#限流数据存储" class="headerlink" title="限流数据存储"></a>限流数据存储</h3><p>对 API 限流是基于 Zuul 过滤器完成的，默认情况下限流数据是记录在内存中的，实际上是用 ConcurrentHashMap 保存，当然也提供了多种存储方式，包括 Redis、Consul、Spring Data JPA，使用这三种存储方式要添加相关依赖。</p><p>然后再添加存储配置，比如使用 Redis 的配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  ratelimit:</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="string">Redis</span></span><br></pre></td></tr></tbody></table></figure><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="限流拦截时机"><a href="#限流拦截时机" class="headerlink" title="限流拦截时机"></a>限流拦截时机</h3><p>限流过滤器是在请求被转发之前调用的</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="限流类型"><a href="#限流类型" class="headerlink" title="限流类型"></a>限流类型</h3><p>限流类型主要包括 url、origin、user 三种</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (types.contains(URL)) {</span><br><span class="line">    joiner.add(route.getPath());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (types.contains(ORIGIN)) {</span><br><span class="line">    joiner.add(getRemoteAddr(request));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (types.contains(USER)) {</span><br><span class="line">    joiner.add(request.getUserPrincipal() != <span class="keyword">null</span> ? request.getUserPrincipal().getName() : ANONYMOUS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>url 类型的限流就是通过请求路径区分</p></li><li><p> origin 是通过客户端 IP 地址区分</p></li><li><p> user 是通过授权用户进行区分，也包括匿名用户</p></li><li><p>可以多个限流类型结合使用</p></li><li><p>如果不配置限流类型，就不做以上区分</p></li></ul><h3 id="拦截限流请求"><a href="#拦截限流请求" class="headerlink" title="拦截限流请求"></a>拦截限流请求</h3><p>在过滤器的 run 方法中判断请求剩余次数，小于 0 就拦截请求：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rate.getRemaining() &lt; <span class="number">0</span>) {</span><br><span class="line">    ctx.setResponseStatusCode(TOO_MANY_REQUESTS.value());</span><br><span class="line">    ctx.put(<span class="string">"rateLimitExceeded"</span>, <span class="string">"true"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(<span class="keyword">new</span> ZuulException(TOO_MANY_REQUESTS.toString(),</span><br><span class="line">            TOO_MANY_REQUESTS.value(), <span class="keyword">null</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，单位时间内剩余请求次数小于 0 时抛出 ZuulRuntimeException，直接返回客户端 TOO_MANY_REQUESTS 异常消息，达到拦截请求的效果。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/yunTerry/spring-cloud-netflix" target="_blank" rel="noopener">https://github.com/yunTerry/spring-cloud-netflix</a></p>]]></content><categories><category>Java</category></categories><tags><tag>Spring Cloud</tag><tag>API网关</tag></tags></entry><entry><title>Nginx 代理的多端口实例负载均衡</title><url>/nginx-lb/</url><content><![CDATA[<p><a href="http://nginx.org/" target="_blank" rel="noopener">Nginx</a> 作为高性能服务器，除了搭建普通的 web 服务，也经常用作反向代理或微服务网关。</p><p><img src="/pic/com/nginx.jpg" alt=""><a id="more"></a></p><p>为了实现服务高可用，通常会启动多个服务实例，这样某个实例挂掉并不影响整体的可用性，Nginx 可以在多个实例中实现负载均衡，并提供了多种负载均衡策略。</p><p>这里在本机开启多个实例，在这些实例中实现负载均衡。</p><p>在 http 配置：<br></p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">upstream backser {</span><br><span class="line">    server localhost:<span class="number">7100</span>;</span><br><span class="line">    server localhost:<span class="number">7200</span>;</span><br><span class="line">    server localhost:<span class="number">7300</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">server {</span><br><span class="line">    listen   <span class="number">8000</span>;</span><br><span class="line">    server_name  backser;</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        proxy_pass   http://backser;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>启动服务端：<br></p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 启动三个Java实例</span></span><br><span class="line">java -jar app.jar --server.port=<span class="number">7100</span></span><br><span class="line">java -jar app.jar --server.port=<span class="number">7200</span></span><br><span class="line">java -jar app.jar --server.port=<span class="number">7300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">start nginx</span><br></pre></td></tr></tbody></table></figure><p></p><p>默认情况 Nginx 会把请求轮流派发给各个实例，实现最简单的负载均衡。</p><p>这种轮询策略可以加入权重，进行负载微调和故障转移：</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">upstream backser {</span><br><span class="line">    server localhost:<span class="number">7100</span> weight=<span class="number">1</span> fail_timeout=<span class="number">3</span>s max_fails=<span class="number">2</span>;</span><br><span class="line">    server localhost:<span class="number">7200</span> weight=<span class="number">2</span> fail_timeout=<span class="number">3</span>s max_fails=<span class="number">2</span>;</span><br><span class="line">    server localhost:<span class="number">7300</span> weight=<span class="number">3</span> fail_timeout=<span class="number">3</span>s max_fails=<span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另一种使用较多的是 ip_hash 策略，能将来自同一 IP 的客户端请求派发给同一个服务实例，在分布式环境中，可以解决 session 不共享的问题。</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">upstream backser {</span><br><span class="line">    server localhost:<span class="number">7100</span> fail_timeout=<span class="number">3</span>s max_fails=<span class="number">2</span>;</span><br><span class="line">    server localhost:<span class="number">7200</span> fail_timeout=<span class="number">3</span>s max_fails=<span class="number">2</span>;</span><br><span class="line">    server localhost:<span class="number">7300</span> fail_timeout=<span class="number">3</span>s max_fails=<span class="number">2</span>;</span><br><span class="line">    ip_hash;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>加载修改后的配置：</p><figure class="highlight py"><table><tbody><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></tbody></table></figure><p>然后同一个客户端请求会发现只有一个实例在响应。</p>]]></content><categories><category>运维</category></categories><tags><tag>运维</tag><tag>API网关</tag></tags></entry><entry><title>Retrofit 巧妙的回调封装</title><url>/retrofit-callback/</url><content><![CDATA[<h2 id="Retrofit回调封装的意义"><a href="#Retrofit回调封装的意义" class="headerlink" title="Retrofit回调封装的意义"></a>Retrofit 回调封装的意义</h2><p>在 Android 的世界里，可以说 <a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a> 已经一统网络请求的江湖，Retrofit 和 Spring Cloud 中的 <a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">Feign</a> 一样都是声明式 REST 请求客户端，都提供了大量注解和完善的 json 对象转换机制，同时不失灵活性。<a id="more"></a></p><p>通常服务端返回都是这种统一格式的对象：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>Android 端拿到这个对象通常要判断 code，然后做对象剥离、token 有效性判断、网络故障处理等，这些如果封装起来统一处理，可以极大简化网络调用。</p><p>这里根据实际开发经验，对使用了 Rxjava 的回调和普通回调分别作了封装，实现以上功能。</p><h2 id="使用Rxjava的回调封装"><a href="#使用Rxjava的回调封装" class="headerlink" title="使用Rxjava的回调封装"></a>使用 Rxjava 的回调封装</h2><p>Retrofit 通过 RxJava2CallAdapter 可以直接将返回结果转换为可观察的对象，拿到 Observable 进行一系列链式处理就方便多了。<br>比如声明一个 API 调用方法：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"/userinfo"</span>)</span><br><span class="line">Observable&lt;BaseModel&lt;User&gt;&gt; getRxUser();</span><br></pre></td></tr></tbody></table></figure><p></p><p>我们通过一个实现 Observer 接口的抽象类对返回结果进行处理，实现对象剥离、token 有效性判断、网络故障的统一处理。</p><p>完整封装代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RxSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">BaseModel</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RxSubscribe</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(BaseModel&lt;T&gt; baseModel)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (baseModel.code == <span class="number">0</span>) {</span><br><span class="line">            onSuccess(baseModel.data);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (baseModel.code == <span class="number">3</span>) {</span><br><span class="line">            <span class="comment">//比如 做token无效统一处理</span></span><br><span class="line">            onFailed(baseModel.code, baseModel.message);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            onFailed(baseModel.code, baseModel.message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HttpException) {</span><br><span class="line">            HttpException ex = (HttpException) t;</span><br><span class="line">            onFailed(ex.code(), ex.message());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            onFailed(-<span class="number">1</span>, t.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>注意这里使用的是 RxJava2，为使代码更简洁，不强制复写 onSubscribe、onFailed 等方法。</p><p>请求回调部分，复写 onSuccess 抽象方法就可以直接拿到剥离后目标对象：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Rest.getRestApi().getRxUser()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> RxSubscribe&lt;User&gt;() {</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(User user)</span> </span>{</span><br><span class="line">  </span><br><span class="line">          }</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure><blockquote><p>还可以复写 onSubscribe 和 onComplete 等方法控制加载中对话框的显示与隐藏。</p></blockquote><h2 id="普通回调的封装"><a href="#普通回调的封装" class="headerlink" title="普通回调的封装"></a>普通回调的封装</h2><p>对于普通回调，返回的是 Call 类型，声明一个 API 调用方法：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"/userinfo"</span>)</span><br><span class="line">Call&lt;BaseModel&lt;User&gt;&gt; getUser();</span><br></pre></td></tr></tbody></table></figure><p></p><p>回调封装部分与上面类似，直接上代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">BaseModel</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseBack</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;BaseModel&lt;T&gt;&gt; call, Response&lt;BaseModel&lt;T&gt;&gt; response)</span> </span>{</span><br><span class="line">        BaseModel&lt;T&gt; baseModel = response.body();</span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful() &amp;&amp; baseModel != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (baseModel.code == <span class="number">0</span>) {</span><br><span class="line">                onSuccess(baseModel.data);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (baseModel.code == <span class="number">3</span>) {</span><br><span class="line">                <span class="comment">//比如 做token无效统一处理</span></span><br><span class="line">                onFailed(baseModel.code, baseModel.message);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                onFailed(baseModel.code, baseModel.message);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            onFailed(response.code(), response.message());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;BaseModel&lt;T&gt;&gt; call, Throwable t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HttpException) {</span><br><span class="line">            HttpException ex = (HttpException) t;</span><br><span class="line">            onFailed(ex.code(), ex.message());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            onFailed(-<span class="number">1</span>, t.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样是复写 onSuccess 方法直接拿到剥离后的目标对象:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Rest.getRestApi().getUser()</span><br><span class="line">    .enqueue(<span class="keyword">new</span> BaseBack&lt;User&gt;() {</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(User user)</span> </span>{</span><br><span class="line">          </span><br><span class="line">         }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p><a href="https://github.com/yunTerry/Retrofit-CallBack" target="_blank" rel="noopener">https://github.com/yunTerry/Retrofit-CallBack</a></p>]]></content><categories><category>Android</category></categories><tags><tag>Android</tag><tag>RESTful</tag></tags></entry><entry><title>云服务器的自动化部署与运维</title><url>/server-auto/</url><content><![CDATA[<p>云计算是 IT 行业的一大变革，未来云计算将成为商业社会的基础设施，国内阿里、腾讯、京东、美团等一众互联网公司都提供云服务，玩玩服务器变得非常容易了，本文简单地总结一下从项目打包到部署运维的经验。<a id="more"></a></p><h2 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h2><p>基于 SpringBoot 开发的项目一般使用 maven 或 gradle 来管理，项目打包成 jar 可执行文件都很简单：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># maven项目打包</span></span><br><span class="line">mvn clean package</span><br><span class="line"></span><br><span class="line"><span class="comment"># gradle项目打包</span></span><br><span class="line">gradlew build</span><br></pre></td></tr></tbody></table></figure><p>实际中很多时候，比如由于数据库配置文件的更改导致测试无法通过，打包就无法顺利完成，这时我们希望不测试直接打包，使用<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">mvn clean package  -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>这条命令可以跳过测试，直接打包，效率提升不少。</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>使用 Xftp 或 WinSCP 等工具登录云主机，把生成的 jar 文件上传到服务器，在 Xshell 中执行:<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">java -jar /root/app.jar</span><br></pre></td></tr></tbody></table></figure><p></p><p>就可以在前台启动项目，这种方式只要控制台关闭，服务就关闭了，通常用来测试项目是否正常运行，正式部署一般用 nohup 命令使服务在后台运行:<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">nohup java -jar /root/app.jar &amp;</span><br></pre></td></tr></tbody></table></figure><p></p><p>部署的时候我们临时指定服务运行的端口号：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">java -jar app.jar --server.port=2030</span><br></pre></td></tr></tbody></table></figure><p></p><p>也可以让它读取不同的配置文件：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">java -jar app.jar --spring.profiles.active=dev</span><br></pre></td></tr></tbody></table></figure><p></p><p>或者直接使用外部的配置文件运行：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">java -jar -Dspring.config.location=app.properties app.jar</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="关闭和重启服务"><a href="#关闭和重启服务" class="headerlink" title="关闭和重启服务"></a>关闭和重启服务</h2><p>程序运行在服务器后台，通过命令行进行关闭和重启管理服务</p><h3 id="用进程管理"><a href="#用进程管理" class="headerlink" title="用进程管理"></a>用进程管理</h3><p>简单的方式就是通过应用进程来管理，我们知道程序运行的端口号，通过端口号查询进程 ID，就可以直接 kill 掉:</p><p>例如使用 <code>lsof -i:5032</code> 或 <code>netstat -anp|grep 5032</code> 可以拿到 5032 端口的 pid，然后直接 <code>kill pid</code> 即可关闭该进程，启动再使用上面的 <code>java -jar</code> 命令即可。</p><p>部署多个服务时，可以写一个 Shell 脚本来管理：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ser1=2001</span><br><span class="line">ser2=2002</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"start ser1:"</span>  val1</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$val1</span>"</span> = <span class="string">"y"</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">nohup java -jar /root/ser1-1.0.jar &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ser1 started"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"start ser2:"</span>  val2</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$val2</span>"</span> = <span class="string">"y"</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">nohup java -jar /root/ser2-1.0.jar &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ser2 started"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 关闭服务</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"stop ser1:"</span>  val3</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$val3</span>"</span> = <span class="string">"y"</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">kill</span> -9 $(netstat -anp|grep <span class="variable">$ser1</span>|awk <span class="string">'{printf $7}'</span>|cut -d/ -f1)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ser1 stopped"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"stop ser2:"</span>  val4</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$val4</span>"</span> = <span class="string">"y"</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">kill</span> -9 $(netstat -anp|grep <span class="variable">$ser2</span>|awk <span class="string">'{printf $7}'</span>|cut -d/ -f1)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ser2 stopped"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="注册为服务"><a href="#注册为服务" class="headerlink" title="注册为服务"></a>注册为服务</h3><p>除了用进程来管理，另一种更优雅的方式就是通过 Linux 的软连接把应用注册为服务，然后通过 start、stop 这样的命令进行管理。</p><p>软连接就类似于 Windows 上的快捷方式，在 <code>/etc/init.d/</code> 文件夹中创建一个软连接，通过这个软连接来管理应用启动和停止：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 为ser1-1.0.jar创建软连接</span></span><br><span class="line">ln -s /root/ser1-1.0.jar /etc/init.d/ser1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予执行权限</span></span><br><span class="line">chmod +x /etc/init.d/ser1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动应用</span></span><br><span class="line">/etc/init.d/ser1 start</span><br><span class="line"><span class="comment"># 关闭或重启</span></span><br><span class="line">/etc/init.d/ser1 stop|restart</span><br></pre></td></tr></tbody></table></figure><h2 id="Python自动化部署"><a href="#Python自动化部署" class="headerlink" title="Python自动化部署"></a>Python 自动化部署</h2><p>前面我们使用 Xshell 和 Xftp 等可视化的工具可以很方便地把 jar 文件上传到服务器，然后运行起来，如果你觉得这些工具还是很繁琐，可以使用 Python 脚本实现一键自动上传和部署。</p><p>Python 提供了一个 <a href="https://github.com/paramiko/paramiko" target="_blank" rel="noopener">paramiko</a> 库，能够支持 SSH 和 SFTP 协议，可以取代 Xshell 和 Xftp，下面是把本机的 jar 文件上传到服务器并运行的 Python 脚本：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line">IP = <span class="string">'106.14.19.127'</span></span><br><span class="line">user = <span class="string">'root'</span></span><br><span class="line">password = <span class="string">'server-pwd'</span></span><br><span class="line"></span><br><span class="line">local_jar = <span class="string">'/target/ser1-1.0.jar'</span></span><br><span class="line">server_jar = <span class="string">'/root/ser1-1.0.jar'</span></span><br><span class="line">server_property = <span class="string">'/root/ser1.properties'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute_cmds</span><span class="params">(ip, name, pwd, cmd)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ssh = paramiko.SSHClient()</span><br><span class="line">        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh.connect(ip, <span class="number">22</span>, name, pwd, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'连接成功'</span></span><br><span class="line">        sftp = ssh.open_sftp()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'正在上传...'</span></span><br><span class="line">        sftp.put(local_jar, server_jar)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'jar上传成功'</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> cmd:</span><br><span class="line">            <span class="keyword">print</span> m</span><br><span class="line">            stdin, stdout, stderr = ssh.exec_command(m)</span><br><span class="line">            out = stdout.readlines()</span><br><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> out:</span><br><span class="line">                <span class="keyword">print</span> o,</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'运行成功'</span></span><br><span class="line">        ssh.close()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'关闭连接'</span></span><br><span class="line">    <span class="keyword">except</span> Exception, error:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'错误:  %s'</span> % (error)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Start deploying %s to server %s'</span> % (server_jar, IP)</span><br><span class="line">    cmd = [</span><br><span class="line">        <span class="string">'echo Start spring...'</span>,</span><br><span class="line">        <span class="string">'nohup java -jar -Dspring.config.location='</span> + server_property + <span class="string">' '</span> + server_jar + <span class="string">' &amp;'</span>,</span><br><span class="line">        <span class="string">'echo All done.'</span></span><br><span class="line">    ]</span><br><span class="line">    a = threading.Thread(target=execute_cmds, args=(IP, user, password, cmd))</span><br><span class="line">    a.start()</span><br></pre></td></tr></tbody></table></figure>]]></content><categories><category>运维</category></categories><tags><tag>SpringBoot</tag><tag>Linux</tag><tag>Python</tag></tags></entry><entry><title>Android 与服务端使用 Https 加密通信</title><url>/Android-https/</url><content><![CDATA[<h2 id="Https证书"><a href="#Https证书" class="headerlink" title="Https证书"></a>Https 证书</h2><p>现在网络安全越来越受重视，通用做法是采用 https 加密通信，使用 https 需要数字证书，只有合法的证书才能被浏览器、操作系统默认支持。<a id="more"></a></p><p>所谓的合法证书其实是在 CA 公司那购买的（原来我们的合法性是花钱从别人那买来的，不得不吐槽这种互联网安全设计真是坑爹），虽然现在也有一些免费 CA 证书，但申请还是挺麻烦，这里我们使用自签名的 https 证书，基于这种没有经过 CA 机构签名的证书，也可以实现 Android 与服务端之间的加密通信。</p><h2 id="服务端使用https"><a href="#服务端使用https" class="headerlink" title="服务端使用https"></a>服务端使用 https</h2><h3 id="生成https证书"><a href="#生成https证书" class="headerlink" title="生成https证书"></a>生成 https 证书</h3><p>JDK 自带的 keytool 工具可以很方便生成 https 证书，可以查看它的使用方法：</p><p><img src="/pic/http/1.jpg" alt=""></p><p>比如这条命令就可以生成一个有效期 10 年的证书：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> spring -validity 3560 -keystore spring.keystore</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="服务端配置https证书"><a href="#服务端配置https证书" class="headerlink" title="服务端配置https证书"></a>服务端配置 https 证书</h3><p>服务端一般使用 Tomcat、Jetty、Undertow 等作为 Servlet 容器，我们将上面生成的 keystore 证书放在项目中，然后在配置文件中引入证书即可：<br></p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">server.ssl.key-store=spring.keystore</span></span><br><span class="line"><span class="string">server.ssl.key-alias=spring</span></span><br><span class="line"><span class="string">server.ssl.key-password=password</span></span><br><span class="line"><span class="string">server.ssl.key-store-type=JKS</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>这样服务端就支持 https 了，启动项目访问服务就要加 https 前缀，如 <a href="https://localhost:8080/user" target="_blank" rel="noopener">https://localhost:8080/user</a></p><h2 id="Android自定义https校验"><a href="#Android自定义https校验" class="headerlink" title="Android自定义https校验"></a>Android 自定义 https 校验</h2><p>如果是花钱买的 CA 证书是不需要额外配置的，Android 系统内部有信任列表，会自行校验通过，这里讲配置自定义 https 校验。</p><p>Android 端通常使用 <a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a> 做网络请求，Retrofit 底层就是 OKhttp，OKhttp 实现自定义 https 校验并不难，主要分三步。</p><h3 id="把证书公钥预埋在APP中"><a href="#把证书公钥预埋在APP中" class="headerlink" title="把证书公钥预埋在APP中"></a>把证书公钥预埋在 APP 中</h3><p>这条命令可以导出证书公钥字符串：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">keytool -list -rfc -keystore spring.keystore</span><br></pre></td></tr></tbody></table></figure><p></p><p><img src="/pic/http/2.jpg" alt=""></p><p>把这个公钥作为一个字符串常量放在项目中供后面校验使用。</p><h3 id="自定义证书校验逻辑"><a href="#自定义证书校验逻辑" class="headerlink" title="自定义证书校验逻辑"></a>自定义证书校验逻辑</h3><p>使用上面的公钥字符串构建 X509TrustManager 对象，在 checkServerTrusted 方法中校验服务端证书：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">X509TrustManager trustManager = <span class="keyword">new</span> X509TrustManager() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">        <span class="comment">//校验客户端证书</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>{</span><br><span class="line">        <span class="comment">//校验服务端证书</span></span><br><span class="line">        X509Certificate ca = (X509Certificate) CertificateFactory.getInstance(<span class="string">"X.509"</span>)</span><br><span class="line">                .generateCertificate(<span class="keyword">new</span> ByteArrayInputStream(PUB_KEY.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (X509Certificate cert : chain) {</span><br><span class="line">            <span class="comment">// 检查服务端证书是否过期</span></span><br><span class="line">            cert.checkValidity();</span><br><span class="line">            <span class="comment">//和APP预埋证书对比</span></span><br><span class="line">            cert.verify(ca.getPublicKey());</span><br><span class="line">            <span class="comment">//证书校验异常时抛出一个CertificateException</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="设置OkHttpClient校验证书"><a href="#设置OkHttpClient校验证书" class="headerlink" title="设置OkHttpClient校验证书"></a>设置 OkHttpClient 校验证书</h3><p>然后使用上面的 trustManager 构建 OkHttpClient</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">SSLSocketFactory sslSocketFactory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    SSLContext sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">    sslContext.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]{trustManager}, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">    sslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line">    </span><br><span class="line">} <span class="keyword">catch</span> (NoSuchAlgorithmException | KeyManagementException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span> HostnameVerifier hostnameVerifier = <span class="keyword">new</span> HostnameVerifier() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">final</span> String hostname,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> SSLSession session)</span> </span>{</span><br><span class="line">        <span class="comment">//服务端主机域名地址校验</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .hostnameVerifier(hostnameVerifier)</span><br><span class="line">        .sslSocketFactory(sslSocketFactory, trustManager)</span><br><span class="line">        .build();</span><br></pre></td></tr></tbody></table></figure><p>使用这个配置好的 OkHttpClient 与服务端交互，就可以支持自定义 https 证书加密通信了，如果服务端证书不符，请求会自动断开。</p>]]></content><categories><category>Android</category></categories><tags><tag>Android</tag><tag>安全</tag></tags></entry><entry><title>用 Node.js 快速开发 RESTful API</title><url>/node-rest/</url><content><![CDATA[<p>前面讲了用 Node.js 开发静态网页服务，这一篇讲用 Node.js 开发 RESTful API 服务，同样是基于 express 框架。</p><a id="more"></a><h2 id="Node-返回-json"><a href="#Node-返回-json" class="headerlink" title="Node 返回 json"></a>Node 返回 json</h2><p>比如开发一个用户信息接口，通过 get 方法返回用户信息：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> json = {</span><br><span class="line">    code: <span class="number">200</span>,</span><br><span class="line">    msg: <span class="string">'请求成功'</span>,</span><br><span class="line">    data: {</span><br><span class="line">        userId: <span class="string">'123456'</span>,</span><br><span class="line">        name: <span class="string">'Terry'</span>,</span><br><span class="line">        blog: <span class="string">'https://yunm.coding.me'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>{</span><br><span class="line">    res.send(json)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">5438</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"启动服务 http://localhost:5438 "</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>运行代码，打开 <a href="http://localhost:5438" target="_blank" rel="noopener">http://localhost:5438</a> ，就可以看到返回的 json：</p><p><img src="/pic/node/node-3.jpg" alt=""></p><h2 id="Node-连接-MySQL-数据库"><a href="#Node-连接-MySQL-数据库" class="headerlink" title="Node 连接 MySQL 数据库"></a>Node 连接 MySQL 数据库</h2><p>Node 可以很方便地从 MySQL 数据库查询数据并返回，例如查询年龄为 20 的用户信息，封装成 RESTful 接口：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection({</span><br><span class="line">    host     : <span class="string">'localhost'</span>,</span><br><span class="line">    user     : <span class="string">'root'</span>,</span><br><span class="line">    password : <span class="string">'xxxx'</span>,</span><br><span class="line">    database : <span class="string">'userdb'</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line">connection.query(<span class="string">'select * from user where age=20'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>{</span><br><span class="line">        res.send(results);</span><br><span class="line">    })</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">5000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'启动服务 http://localhost:5000'</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>运行代码，打开 <a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a> ，就可以看到返回的 json：</p><p><img src="/pic/node/node-4.jpg" alt=""></p><p>当然了，Node.js 在分布式系统开发方面并不成熟，现阶段 node 貌似更适合快速开发小型服务，大型系统还是要用 Spring Cloud 等做服务注册发现，做高可用。</p>]]></content><categories><category>Node.js</category></categories><tags><tag>MySQL</tag><tag>Node.js</tag><tag>RESTful</tag><tag>express</tag></tags></entry><entry><title>六行代码搭建静态网站</title><url>/node-static/</url><content><![CDATA[<p>很多人觉得用 SpringBoot 开发后端服务太方便了，但是 Node.js 可能比 SpringBoot 更方便，用 SpringBoot 你要按部就班先新建一个工程，然后再写逻辑代码，但用 Node.js 直接拿一个 js 文件就开写，写完直接一条命令 node xx.js 就跑起来了，启动速度也甩 SpringBoot 几条街。<a id="more"></a></p><p>不得不承认 node 很简洁、高效，甚至可以说，在 Node.js 面前，Java 的 Spring 框架显得有些臃肿不堪。</p><p>比如要搭一个静态网页，node 只需六行代码就可以搞定。</p><h2 id="node搭建静态博客"><a href="#node搭建静态博客" class="headerlink" title="node搭建静态博客"></a>node 搭建静态博客</h2><p>就拿我的博客为例，先从 github 上把博客的网页源码下载下来：</p><p><a href="https://github.com/yunTerry/yunTerry.github.io" target="_blank" rel="noopener">https://github.com/yunTerry/yunTerry.github.io</a></p><p>把这些静态 html、css、js 网页文件放在电脑 D 盘 blog 文件夹下，路径：D:/blog/，新建一个 app.js 中加入如下代码：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'D:/blog/'</span>))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">5000</span>, () =&gt; {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'启动服务 http://localhost:5000'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>然后执行 <code>node app.js</code> ，浏览器打开 <a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a> 就能看到网页服务就跑起来了：</p><p><img src="/pic/node/node-static.jpg" alt=""></p><p>当然运行这段代码需要 express 模块，全局安装 express 模块：<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g express</span><br></pre></td></tr></tbody></table></figure><p></p><p>也可以简写成<br></p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">npm i -g express</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="其他方式搭建"><a href="#其他方式搭建" class="headerlink" title="其他方式搭建"></a>其他方式搭建</h2><p>当然用 SpringBoot 搭建也很简单，只需三行配置：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server.port=5000</span><br><span class="line">spring.mvc.static-path-pattern=/**</span><br><span class="line">spring.resources.static-locations=file:D:/blog/</span><br></pre></td></tr></tbody></table></figure><p>或者用 Nginx 也很简单:</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">   listen   5000;</span><br><span class="line">   </span><br><span class="line">   location / {</span><br><span class="line">       root   D:/blog;</span><br><span class="line">       index  index.html index.htm;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content><categories><category>Node.js</category></categories><tags><tag>Node.js</tag><tag>express</tag></tags></entry><entry><title>Spring Cloud 与 Consul 服务发现</title><url>/cloud-consul/</url><content><![CDATA[<h2 id="Consul服务发现"><a href="#Consul服务发现" class="headerlink" title="Consul服务发现"></a>Consul 服务发现</h2><p>Consul 是一个开源的服务注册发现工具，采用 Go 语言开发，支持多数据中心分布式高可用的服务发现和配置共享，广泛应用在大规模分布式系统中。</p><p>Spring Cloud 原生支持使用 Consul 做服务注册发现，类似 Eureka、ZooKeeper。<a id="more"></a></p><p>下载 <a href="https://www.consul.io/" target="_blank" rel="noopener">Consul</a> 软件，对其运行 <code>consul agent -dev</code>，启动开发模式</p><p>在项目中添加依赖<br></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">compile('org.springframework.cloud:spring-cloud-starter-consul-discovery')</span><br></pre></td></tr></tbody></table></figure><p></p><p>添加 consul 注册中心配置<br></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">spring.cloud.consul.host=localhost</span><br><span class="line">spring.cloud.consul.port=<span class="number">8500</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>打开 <a href="http://localhost:8500" target="_blank" rel="noopener">http://localhost:8500</a> 查看服务注册情况</p><p><img src="/pic/com/consul.png" alt=""></p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>service provider 在 5030 端口提供一组管理用户信息的接口：<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function">User <span class="title">addUser</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getauser"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>配置 MySQL 数据库<br></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">spring.datasource.dbcp2.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/userdb?useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=qqqq</span><br><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>这里使用 feign 调用服务提供者，service consumer 在 5031 端口提供用户信息相关接口<br></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user/add/{name}"</span>)</span><br><span class="line"><span class="function">User <span class="title">addUser</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/{id}"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行 post 请求到 <a href="http://localhost:5031/user/add/Lerry" target="_blank" rel="noopener">http://localhost:5031/user/add/Lerry</a> 向数据库添加一条数据</p><p>通过 <a href="http://localhost:5031/user" target="_blank" rel="noopener">http://localhost:5031/user</a> 得到用户列表<br></p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Lerry"</span>,</span><br><span class="line">    <span class="attr">"img"</span>: <span class="string">"http://up.qqjia.com/z/16/tu17317_45.png"</span>,</span><br><span class="line">    <span class="attr">"sex"</span>: <span class="string">"girl"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="number">1499761984675</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"kity"</span>,</span><br><span class="line">    <span class="attr">"img"</span>: <span class="string">"http://up.qqjia.com/z/16/tu17317_45.png"</span>,</span><br><span class="line">    <span class="attr">"sex"</span>: <span class="string">"girl"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="number">1499762171942</span></span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p><a href="https://github.com/yunTerry/spring-cloud-consul" target="_blank" rel="noopener">https://github.com/yunTerry/spring-cloud-consul</a></p>]]></content><categories><category>Java</category></categories><tags><tag>Spring Cloud</tag><tag>SpringBoot</tag><tag>服务发现</tag><tag>MySQL</tag></tags></entry><entry><title>书法之美</title><url>/shufa/</url><content><![CDATA[<p><img src="/pic/shufa/sf-1.jpg" alt=""><a id="more"></a></p><p><img src="/pic/shufa/sf-2.jpg" alt=""></p><p><img src="/pic/shufa/sf-3.jpg" alt=""></p><p><img src="/pic/shufa/sf-4.jpg" alt=""></p><p><img src="/pic/shufa/sf-5.jpg" alt=""></p><p>摄于广州余荫山房</p>]]></content><categories><category>随笔</category></categories></entry><entry><title>互联网行业的多样性思考</title><url>/duo-yang-xin/</url><content><![CDATA[<p>谷歌最近有个工程师因为发文涉嫌性别歧视而被解雇，忽然发现硅谷科技公司最近都开始重视员工多样性建设，谷歌还专门任命了多样性副总裁，苹果最近在其总部举行员工多样性庆祝活动（当然不知道他们为什么庆祝）。<a id="more"></a></p><p>这确实是一个值得重视的问题，随着互联网的发展，技术人员群体越来越同质化，男性越来越多，女性比例越来越少，大家在一起的话题寥寥无几，人与人之间的交流越发枯燥乏味，技术给人带来便利和财富，但却让人感觉更加孤独和乏味。</p><p>其实想想乔布斯年轻时代，至少还有一帮嬉皮士在那搞怪，而现在呢，大家如此的相似，技术几乎成了唯一的话题，人的多样性降低了很多，这是一个我们不得不深思的问题。</p><p><img src="/pic/duo/duo-3.jpg" alt=""></p><p>多样性本是生物学上一个重要概念，物种的多样性是种群得以繁荣的根本，你看那海水中的赤潮，那是某些藻类生物大量繁殖的结果，它们很繁盛能将海水染红，但它们都是同类，他们的多样性极低，所以那繁盛只是它们即将消亡前的回光返照。</p><p><img src="/pic/duo/duo-4.jpg" alt=""></p><p>今天互联网行业也面临类似的危机，马云很早就强调女性员工的重要性，我们迫切需要提高这个行业人员的多样性，不仅是性别，还包括思想的多样性、价值观的多样性、兴趣爱好的多样性・・・・・・过度的同质化会让风险越来越集中，也许当某一天风险集中爆发时我们将措手不及。</p>]]></content><categories><category>随笔</category></categories></entry></search>